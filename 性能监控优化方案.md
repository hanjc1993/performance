# 性能监控优化方案

## 定义

-   对页面内的关键指标进行采集、上报、展示、告警、优化的闭环流程
-   通常是指性能指标，广义上能否正常显示页面也算作性能指标，比如资源报错、代码报错等
-   对于非必要访问的页面，页面加载速度与用户留存率呈指数相关，当 3s 后仍未加载时，留存率开始明显下降

## 意义

-   查看代码在客户端运行的真实情况
    -   toC 开发难点之一是用户行为不可控，包括设备、网络、操作
    -   通过埋点发现问题，无需用户配合
    -   埋点已经监控了用户操作，我们要对其他信息进行采集
-   对异常状态进行自动告警
    -   即使进行了第一条的信息采集，但必须手动去查才能知道结果。手动查询的缺点很明显
        -   大部分情况都是没有异常，查了也浪费时间，同时产生心智负担
        -   比如半夜开始大面积出问题，如果手动查询最快也得第二天
        -   数据量大，每次手动查询难免有错漏
-   找出性能瓶颈，或报错原因，即时处理
    -   对于单个项目，性能在模块就看的差不多了，统计意义不是很大，具体如下
        -   不同机型、内核的表现
        -   对于网络、手表状态有基本的判断
            -   比如 html 都下载了 2s，接下来的加载自然会很慢
            -   sourceTiming 过滤
    -   对于框架设计，在框架稳定后，意义也不大，具体如下
        -   需要借助外部，比如 app 和手表端
        -   启动 webview 耗时、内存占用
        -   开始下载 html 之前、除启动 webview 之外的耗时明细

## 注意事项

### 谨防要素过多

-   不好实现
-   不易移植
-   代码体积太大
-   埋点内容过长
-   可能影响性能

### 结合擅长领域，避免重复劳动

-   请求报错
    -   APP 和手表端有请求日志，如果请求报错导致了代码报错，才需要 H5 记录
    -   服务器端更适合做请求报错监控，也正在做
-   页面时长统计
    -   容器来做会准确得多
-   页面启动过程中的性能指标
    -   H5 来统计最方便，目前的 app 也做了相关的统计
    -   有的方案中针对低版本用户，在不支持 performance API 时，通过 app 来获取性能数据
        -   但其实兼容是做不尽的，舍弃个别用户的统计就可以降低 APP 启动成本，提高绝大多数人的体验

### 涉及隐私

-   不应获取用户定位、uuid 等

### 与 webview 耦合性强

-   如果捆绑容器版本，存在隐患

### 运算量大，或引入外部插件

-   不应影响到业务代码的加载和执行速度

### APP 端交互库的 xxxxx 方法

-   device 属性含 address、deviceId、model、watchModel，没意义或可替代
-   wbPfm 包含 netType，webInit，webResponse，webTotal，在 ios 和安卓上效果不一致
-   感觉这个方法是半成品，不建议使用甚至在 APP 中关闭相关逻辑

### 兼容性

-   H5 性能监控的核心 performance API 存在不兼容的可能
    -   内部的属性也存在不兼容的可能，比如.getEntries()及相关方法的兼容性较差
        -   展讯，ios8 不支持，ios9 ios10 部分不支持
    -   使用 performance.timing 代替，自行计算结果，必须延迟才能拿到所有数据
    -   .timing 仍需要容错处理
-   交互库
    -   仅针对第四套进行监控，降低兼容难度

## 实施方案

### 优化埋点数据

-   性能监控只针对首屏，比如单页应用只需要做一次。报错监控一直都有
-   容器端
    -   启动 webview 时间（性能）
    -   触发启动 webview 的功能名称（通用）
    -   webview 崩溃日志（报错）
    -   机型/系统版本（通用）
    -   APP 端额外埋点（通用）
        -   系统
    -   表端额外埋点（通用）
        -   webview 内存占用、剩余内存等（可选）
-   H5
    -   performance.timing 计算值（性能），简称perT
        -   totalTime: perT.domComplete - perT.navigationStart, // 完整加载时间，不含 onload 事件执行
        -   DNSTime: perT.domainLookupEnd - perT.domainLookupStart, // DNS 查询时间
        -   domTime: perT.domInteractive - perT.domLoading, // 解析 dom 树时间，含 js 等阻塞性资源，不含图片等
        -   ttfb: perT.responseStart - perT.navigationStart, // 请求准备时间 ttfb
    -   网络类型（性能）
        -   表端：可从 appD 中获取 .network
        -   APP：交互库 xxxxx 方法
    -   项目名（通用）
        -   建议英文，能识别就行
    -   机型/系统/系统版本
        -   可从 appD 中获取（通用）
        -   表端 ：model（手表型号）、version（固件版本）、appVersion（应用版本）
        -   APP ：model（手机型号）、systemVersion（系统版本）、version（应用版本）
    -   报错文本（报错）

### 自动报警

    均可用 node 实现， 已有企业微信 robot 的 demo
    需要大数据组技术支持，添加查询触发接口，及查询完成的回调能力
    大数据查询结果需要存储，方便回溯历史、图表分析

-   自动查询：每天夜间自动对监控埋点数据进行查询，查询前一天的数据
-   自动分析：每天早上自动分析数据，并输出结果
-   自动告警：按照设置的阈值进行告警，推送到企业微信

### 图表输出

-   做一个后台系统，针对监控数据进行图表展示
    -   数据来源于已存储的大数据查询结果
-   支持各种筛选功能，比如项目名称、时间、机型等

### 定期复盘

    定期组织复盘，回顾历史问题，不断优化

## 工作分配

### H5

-   完善[性能监控 js](http://内网地址/)
-   如选用 node 中间层，则需完成相关开发，否则由服务器开发
-   如需图表输出，则需开发平台

### 容器端

-   讨论最佳实现方案，比如
    -   APP 端优化 xxxxx 方法，表端添加对应方法
    -   新增方法，H5 将数据作为参数传递给容器端，由容器端进行埋点
    -   不使用数据互通，容器和 H5 各自埋点

### 大数据组

-   实现查询触发接口、查询成功回调接口等

## 执行流程

-   先确定收益
    由于 APP 端对 H5 性能要求不高，这套性能监控的方案能否推广，需要有数据进行支撑。所以先以最低成本执行，目标确定收益
    1. 通过大数据，手动查询既有数据，看下可能存在的收益
    2. 对 h5 的性能监控方法进行优化，推广后跑一段时间，再查大数据结果
-   低耦合开发
    -   尽量采用各自埋点的方案，H5 和容器之间不进行性能指标的传递，切断耦合
    -   分为收集、自动报警、图表输出三个模块，可以逐步开发，也可选并行开发
